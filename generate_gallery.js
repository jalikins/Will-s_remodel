// --- generate_gallery.js (Upgraded Version 2.0) ---

const fs = require('fs');
const path = require('path');

// Configuration
const images_root_path = path.join(__dirname, 'images', 'projects');
const output_file = path.join(__dirname, 'js', 'gallery_data.js');
const image_extensions = ['.webp', '.jpg', '.jpeg', '.png', '.gif'];

console.log(`Scanning for images in: ${images_root_path}`);

// This function will recursively find all image file paths
function find_all_images(directory) {
    let all_files = [];
    const files = fs.readdirSync(directory);
    for (const file of files) {
        const full_path = path.join(directory, file);
        if (fs.statSync(full_path).isDirectory()) {
            all_files = all_files.concat(find_all_images(full_path));
        } else if (image_extensions.includes(path.extname(file).toLowerCase())) {
            all_files.push(full_path);
        }
    }
    return all_files;
}

// Main execution block
try {
    // 1. Get a flat list of every single image file
    const all_image_paths = find_all_images(images_root_path);

    // 2. Filter out any images with "old_" in the filename
    const new_image_paths = all_image_paths.filter(p => !path.basename(p).toLowerCase().includes('old_'));
    
    // 3. Group images by a common "base name" to find pairs
    const image_groups = {};

    for (const image_path of new_image_paths) {
        // Create a unique identifier for each image, ignoring size folders and suffixes
        // e.g., '.../beacon/bathroom/new_bathroom(1)'
        const base_identifier = image_path
            .replace(path.sep + 'large' + path.sep, path.sep) // remove '/large/'
            .replace(path.sep + 'small' + path.sep, path.sep) // remove '/small/'
            .replace(/_large|_small/i, '')
            .replace(path.extname(image_path), '');

        if (!image_groups[base_identifier]) {
            image_groups[base_identifier] = {};
        }

        // Store the path based on whether it's a small or large version
        if (image_path.toLowerCase().includes('_small')) {
            image_groups[base_identifier].small = image_path;
        } else if (image_path.toLowerCase().includes('_large')) {
            image_groups[base_identifier].large = image_path;
        } else {
            image_groups[base_identifier].single = image_path;
        }
    }

    // 4. Process the grouped images to create the final imageData array
    const image_data = Object.values(image_groups).map(group => {
        // Determine the correct src and largeSrc
        const src = group.small || group.single;      // Prioritize the small version for the thumbnail
        const largeSrc = group.large || group.single; // Prioritize the large version for the lightbox

        // If we couldn't find a valid source for the thumbnail, skip this image
        if (!src) return null;

        // The category is the name of the folder containing the image
        const category = path.basename(path.dirname(src));

        // Create a nice alt text from the filename
        const alt_text = path.basename(src, path.extname(src))
            .replace(/_small/i, '')
            .replace(/_/g, ' ')
            .replace(/-/g, ' ')
            .replace(/\(\d+\)/, '')
            .replace(/\b\w/g, l => l.toUpperCase())
            .trim();

        return {
            category: category,
            src: `../${path.relative(__dirname, src).replace(/\\/g, '/')}`,
            largeSrc: `../${path.relative(__dirname, largeSrc).replace(/\\/g, '/')}`,
            alt: `${alt_text} - ${category.charAt(0).toUpperCase() + category.slice(1).replace(/_/g, ' ')}`
        };
    }).filter(Boolean); // Filter out any null entries

    // 5. Sort the final data alphabetically by category
    image_data.sort((a, b) => a.category.localeCompare(b.category));

    // 6. Create the final content for the JS file
    const file_content = `// This file is auto-generated by generate-gallery.js. DO NOT EDIT MANUALLY.\nconst imageData = ${JSON.stringify(image_data, null, 4)};`;

    // 7. Write the data to the output file
    fs.writeFileSync(output_file, file_content);

    console.log(`✅ Success! ${image_data.length} images processed and filtered.`);
    console.log(`✅ Data written to ${output_file}`);

} catch (error) {
    console.error('❌ Error scanning directory or writing file:', error);
}